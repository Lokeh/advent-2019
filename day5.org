#+begin_src clojure
(ns advent-2019.intcode)

(declare parameters)

(declare operation)

(declare pad)

(require '[clojure.string :as string])

(defn create-program [prog-string input]
  {:memory (string/split prog-string #",")
   :pointer 0
   :input input
   :output []
   :running? true})

(defmulti instruction (fn [opcode modes program] opcode))

(defn compute [{:keys [memory pointer input] :as program}]
  (try
    (let [[modes op] (operation memory pointer)]
      (instruction op modes program))
    (catch Exception e
      (throw (ex-info "An error occurred"
                      program
                      e)))))

(defn char->int [c]
  (-> c
      (String/valueOf)
      (Integer/parseInt)))

(defn operation [memory pointer]
  (let [opstring (get memory pointer)
        ;; read modes right-to-left
        modechars (drop-last 2 opstring)
        codestring (apply str (take-last 2 opstring))]
    [(map char->int modechars) (Integer/parseInt codestring)]))

(operation ["3"] 0)
;; => [() 3]

(operation ["1101"] 0)
;; => [(1 1) 1]

(operation ["11101"] 0)
;; => [(1 1 1) 1]

(operation ["99"] 0)
;; => [() 99]

(defn pad [xs n]
  (if (< (count xs) n)
    (pad (cons 0 xs) n)
    xs))

(pad [1 1] 3)
;; => (0 1 1)

(pad '(1) 3)
;; => (0 0 1)

(pad '(1 0 1 1) 3)
;; => (1 0 1 1)

(defn parameters [memory pointer modes]
  {:pre [(vector? memory)]}
  (let [ps (subvec memory (inc pointer))
        mps (map vector modes (take (count modes) ps))]
    (for [[m p] mps]
      (case m
        0 (-> memory
              (get (Integer/parseInt p))
              (Integer/parseInt))
        1 (Integer/parseInt p)))))

(parameters ["1002" "4" "3" "4" "33"] 0 '(0 1 1))
;; => (33 3 4)



(defn run [program input]
  (let [compute-seq (iterate compute (create-program program input))]
    (-> (take-while :running? compute-seq)
        (last)
        :output)))

(defmethod instruction 99
  [_ _ program]
  (assoc program :running? false))

(defmethod instruction 1
  ;; add
  [_ modes {:keys [memory pointer] :as program}]
  (let [[_ m2 m3] (pad modes 3)
        ;; always treat last parameter as immediate
        [v1 v2 rptr] (parameters memory pointer [m3 m2 1])]
    (-> program
        (update :memory assoc rptr (str (+ v1 v2)))
        (update :pointer + 4))))

(defmethod instruction 2
  ;; multiply
  [_ modes {:keys [memory pointer] :as program}]
  (let [[_ m2 m3] (pad modes 3)
        [v1 v2 rptr] (parameters memory pointer [m3 m2 1])]
    (-> program
        (update :memory assoc rptr (str (* v1 v2)))
        (update :pointer + 4))))

(defmethod instruction 3
  ;; set as input
  [_ modes {:keys [memory pointer input] :as program}]
  (let [[rptr] (parameters memory pointer [1])]
    (-> program
        (update :memory assoc rptr input)
        (update :pointer + 2))))

(defmethod instruction 4
  ;; output
  [_ modes {:keys [memory pointer] :as program}]
  (let [[v] (parameters memory pointer (pad modes 1))]
    (-> program
        (update :output conj v)
        (update :pointer + 2))))

(-> "1002,4,3,4,33"
    (create-program "1")
    (compute))
;; => {:memory ["1002" "4" "3" "4" "132"], :pointer 4, :input "1", :output [], :running? true}


(-> "3,0,4,0,99"
    (create-program "1")
    (compute)
    (compute)
    (compute))
;; => {:memory ["1" "0" "4" "0" "99"], :pointer 4, :input "1", :output [1], :running? false}

(-> "3,0,4,0,99"
    (run "1"))
;; => [1]

(ns advent-2019.day5)

(require '[clojure.java.io :as io])

(prn ::part1 (last (-> (io/resource "day5.input")
                       (slurp)
                       (advent-2019.intcode/run "1"))))
;; => [0 0 0 0 0 0 0 0 0 7566643]


(ns advent-2019.intcode)

(defmethod instruction 5
  ;; jump if true
  [_ modes {:keys [memory pointer] :as program}]
  (let [[m2 m1] (pad modes 2)
        [v1 v2] (parameters memory pointer [m1 m2])]
    (if (zero? v1)
      ;; noop
      (update program :pointer + 3)
      (-> program
          (assoc :pointer v2)))))

;; TODO standardize mode selection
(defmethod instruction 6
  ;; jump if false
  [_ modes {:keys [memory pointer] :as program}]
  (let [[m2 m1] (pad modes 2)
        [v1 v2] (parameters memory pointer [m1 m2])]
    (if (not (zero? v1))
      ;; noop
      (update program :pointer + 3)
      (-> program
          (assoc :pointer v2)))))

(defmethod instruction 7
  ;; less than
  [_ modes {:keys [memory pointer] :as program}]
  (let [[_ m2 m1] (pad modes 3)
        [v1 v2 rptr] (parameters memory pointer [m1 m2 1])]
    (-> program
        (update :memory assoc rptr (if (< v1 v2)
                                     "1" "0"))
        (update :pointer + 4))))

(defmethod instruction 8
  ;; equal to
  [_ modes {:keys [memory pointer] :as program}]
  (let [[_ m2 m1] (pad modes 3)
        [v1 v2 rptr] (parameters memory pointer [m1 m2 1])]
    (prn v1 v2 rptr)
    (-> program
        (update :memory assoc rptr (if (= v1 v2)
                                        "1" "0"))
        (update :pointer + 4))))


;; equal to position test
(-> "3,9,8,9,10,9,4,9,99,-1,8"
    (run "8")
    (last)
    (= 1))
;; => true

(-> "3,9,8,9,10,9,4,9,99,-1,8"
    (run "9")
    (last)
    (= 0))
;; => false


;; less than position test
(-> "3,9,7,9,10,9,4,9,99,-1,8"
    (run "4")
    (last)
    (= 1))
;; => true

(-> "3,9,7,9,10,9,4,9,99,-1,8"
    (run "9")
    (last)
    (= 0))
;; => true


;; equal to immediate test
(-> "3,3,1108,-1,8,3,4,3,99"
    (run "8")
    (last)
    (= 1))
;; => true

(-> "3,3,1108,-1,8,3,4,3,99"
    (run "9")
    (last)
    (= 0))
;; => true


;; less than immediate test
(-> "3,3,1107,-1,8,3,4,3,99"
    (run "4")
    (last)
    (= 1))
;; => true

(-> "3,3,1107,-1,8,3,4,3,99"
    (run "9")
    (last)
    (= 0))
;; => true


;; jump test
(-> "3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9"
    (run "0")
    (last)
    (= 0))
;; => true

(-> "3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9"
    (run "1")
    (last)
    (= 1))
;; => true


;; immediate
(-> "3,3,1105,-1,9,1101,0,0,12,4,12,99,1"
    (run "1")
    (last)
    (= 1))
;; => true

(-> "3,3,1105,-1,9,1101,0,0,12,4,12,99,1"
    (run "0")
    (last)
    (= 0))
;; => true


;; large example
(def large-example "3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99")

(-> large-example
    (run "4")
    (last)
    (= 999))
;; => true

(-> large-example
    (run "8")
    (last)
    (= 1000))
;; => true

(-> large-example
    (run "9")
    (last)
    (= 1001))
;; => true

(ns advent-2019.day5)

(-> (io/resource "day5.input")
    (slurp)
    (advent-2019.intcode/run "5"))
;; => [9265694]

#+end_src
